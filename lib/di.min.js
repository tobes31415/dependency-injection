let e;class t{constructor(){this.instances=new Map,this.resolvers=new Map,this.useFactory=this.useFactory.bind(this),this.resolve=this.resolve.bind(this)}useFactory(e,t){if(this.instances.has(e))throw new Error("This token has already been resolved");if(this.resolvers.has(e))throw new Error("A resolver has already been supplied for this token");if("function"!=typeof t)throw new Error("useFactory expects a function");this.resolvers.set(e,t)}useClass(e,t){this.useFactory(e,()=>this.resolve(t))}useObject(e,t){this.useFactory(e,()=>t)}resolve(t){const s=!e;try{if(s&&(e=this),e!==this)throw new Error("Cross Context resolution detected");if(!this.instances.has(t)){const e=(this.resolvers.get(t)||this.defaultResolver)(t);if(!e)throw new Error("Resolver didn't return an instance");this.instances.set(t,e)}return this.instances.get(t)}finally{s&&(e=void 0)}}defaultResolver(e){if("function"!=typeof e)throw new Error("Tokens must either be factory functions, or you must supply a resolver before trying to resolve them");return new e}}const s=new class{constructor(){this.defaultRoot=new t}useFactory(e,t){return this.context().useFactory(e,t)}useClass(e,t){return this.context().useClass(e,t)}useObject(e,t){return this.context().useObject(e,t)}resolve(e){return this.context().resolve(e)}context(){return e||this.defaultRoot}};export function createRoot(){return new t};export default s;export{s as DI};